---
title: YUV(YCbCr) 与RGB
date: "2020-07-12 21:25:00"
tags: [color,photograph,introduction,docs]
category: blog
---
\*\*\*注意！\*\*\*本文所涉及的内容皆为RGB和YUV总述，并没有涉及10bit的内容。

关于10bit的内容参见Microsoft的文档 [10-bit and 16-bit YUV Video Formats](https://docs.microsoft.com/zh-cn/windows/win32/medfound/10-bit-and-16-bit-yuv-video-formats)

本文转载自CSDN，遵循CC 4.0 BY-SA协议。

[RGB、YUV和YCbCr三种颜色空间](https://blog.csdn.net/byhook/article/details/84262330)

[图解RGB565、RGB555、RGB16、RGB24、RGB32、ARGB32等格式的区别](https://blog.csdn.net/u010186001/article/details/52800250)

<!-- more -->

## RGB颜色系统

`RGB` 色彩模式是工业界的一种颜色标准，是通过对红、绿、蓝三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。

### RGB16

`RGB16` 数据格式主要有二种：`RGB565` 和 `RGB555`。

#### **RGB565**

> 每个像素用16比特位表示，占2个字节，RGB分量分别使用5位、6位、5位。

![](https://img-blog.csdnimg.cn/20181121131550287.png)

```java

//获取高字节的5个bit
R = color & 0xF800;
//获取中间6个bit
G = color & 0x07E0;
//获取低字节5个bit
B = color & 0x001F;

```

#### **RGB555**

> 每个像素用16比特表示，占2个字节，RGB分量都使用5位(最高位不用)。

![](https://img-blog.csdnimg.cn/20181121131759287.png)

```java

//获取高字节的5个bit
R = color & 0x7C00;
//获取中间5个bit
G = color & 0x03E0;
//获取低字节5个bit
B = color & 0x001F;

```

### RGB24

> `RGB24` 图像每个像素用8比特表示，占1个字节，注意：在内存中RGB各分量的排列顺序为：`BGR BGR BGR`。

![](https://img-blog.csdnimg.cn/20181121131934533.png)

### RGB32

> `RGB32` 每个像素用32比特表示，占4个字节，`R，G，B` 分量分别用8个bit表示，存储顺序为 `B，G，R`，最后8个字节保留。注意：在内存中RGB各分量的排列顺序为：`BGRA BGRA BGRA`。

#### **ARGB32**

> 本质就是带 `alpha` 通道的 `RGB24` ，与 `RGB32` 的区别在与，保留的8个bit用来表示透明，也就是 `alpha` 的值。

在内存中的分量排列顺序如下：

![](https://img-blog.csdnimg.cn/20181121132055320.png)

```java

R = color & 0x0000FF00;
G = color & 0x00FF0000;
B = color & 0xFF000000;
A = color & 0x000000FF;

```

## YUV和YCbCr

YUV是北美NTSC系统和欧洲PAL系统中**模拟电视**信号编码的基础。

在YUV空间中，每一个颜色有一个亮度信号Y，和两个色度信号U和V。亮度信号是强度的感觉，它和色度信号断开，这样的话强度就可以在不影响颜色的情况下改变。

YUV使用RGB的信息，但它从全彩色图像中产生一个黑白图像，然后提取出三个主要的颜色变成两个额外的信号来描述颜色。把这三个信号组合回来就可以产生一个全彩色图像。

Y通道描述Luma信号，它与亮度信号有一点点不同，值的范围介于亮和暗之间。 Luma是黑白电视可以看到的信号。U (Cb) 和V (Cr) 通道从红 (U) 和蓝 (V) 中提取亮度值来减少颜色信息量。这些值可以从新组合来决定红，绿和蓝的混合信号。

YCbCr颜色空间是YUV的国际标准化变种，在**数字电视和图像压缩**（比如JPEG ）方面都有应用。

YCbCr是在世界数字组织视频标准研制过程中作为ITU - R BT 601建议的一部分, 其实是YUV经过缩放和偏移的翻版。其中Y与YUV中的Y含义一致, Cb , Cr同样都指色彩, 只是在表示方法上不同而已。在YUV家族中, YCbCr是在计算机系统中应用最多的成员, 其应用领域很广泛,JPEG、MPEG均采用此格式。**一般人们所讲的YUV大多是指YCbCr**。

### YCbCr采样格式

主要的采样格式有YCbCr 4:2:0、YCbCr 4:2:2、YCbCr 4:1:1和YCbCr 4:4:4。其中YCbCr 4:1:1比较常用，其含义为：每个点保存一个8bit的亮度值(也就是Y值), 每2 x 2个点保存一个Cr和Cb值, 图像在肉眼中的感觉不会起太大的变化。所以, 原来用RGB(R,G,B都是8bit unsigned) 模型, 每个点需要8 x 3 = 24 bits， 而现在仅需要8 + (8/4) + (8/4) = 12bits, 平均每个点占12bits。这样就把图像的数据压缩了一半。

上边仅给出了理论上的示例，在实际数据存储中是有可能是不同的，下面给出几种具体的存储形式：

### YUV 4:4:4

YUV三个信道的抽样率相同，因此在生成的图像里，每个象素的三个分量信息完整（每个分量通常8比特），经过8比特量化之后，未经压缩的每个像素占用3个字节。

下面的四个像素为: \[Y0 U0 V0\] \[Y1 U1 V1\] \[Y2 U2 V2\] \[Y3 U3 V3\]

存放的码流为: Y0 U0 V0 Y1 U1 V1 Y2 U2 V2 Y3 U3 V3

### YUV 4:2:2

每个色差信道的抽样率是亮度信道的一半，所以水平方向的色度抽样率只是4:4:4的一半。对非压缩的8比特量化的图像来说，每个由两个水平方向相邻的像素组成的宏像素需要占用4字节内存(例如下面映射出的前两个像素点只需要Y0、Y1、U0、V1四个字节)。

下面的四个像素为: \[Y0 U0 V0\] \[Y1 U1 V1\] \[Y2 U2 V2\] \[Y3 U3 V3\]

存放的码流为: Y0 U0 Y1 V1 Y2 U2 Y3 V3

映射出像素点为：\[Y0 U0 V1\] \[Y1 U0 V1\] \[Y2 U2 V3\] \[Y3 U2 V3\]

### YUV 4:1:1

4:1:1的色度抽样，是在水平方向上对色度进行4:1抽样。对于低端用户和消费类产品这仍然是可以接受的。对非压缩的8比特量化的视频来说，每个由4个水平方向相邻的像素组成的宏像素需要占用6字节内存

下面的四个像素为: \[Y0 U0 V0\] \[Y1 U1 V1\] \[Y2 U2 V2\] \[Y3 U3 V3\]

存放的码流为: Y0 U0 Y1 Y2 V2 Y3

映射出像素点为：\[Y0 U0 V2\] \[Y1 U0 V2\] \[Y2 U0 V2\] \[Y3 U0 V2\]

### YUV4:2:0

4:2:0并不意味着只有Y,Cb而没有Cr分量。它指得是对扫描来说，只有色度分量以2:1的抽样率存储。相邻的扫描行存储不同的色度分量，也就是说，如果一行是4:2:0的话，下一行就是4:0:2，再下一行是4:2:0。对每个色度分量来说，水平方向和竖直方向的抽样率都是2:1，所以可以说色度的抽样率是4:1。对非压缩的8比特量化的视频来说，每个由2x2个2行2列相邻的像素组成的宏像素需要占用6字节内存。

下面八个像素为：\[Y0 U0 V0\] \[Y1 U1 V1\] \[Y2 U2 V2\] \[Y3 U3 V3\] \[Y5 U5 V5\] \[Y6 U6 V6\] \[Y7U7 V7\] \[Y8 U8 V8\]

存放的码流为：Y0 U0 Y1 Y2 U2 Y3 Y5 V5 Y6 Y7 V7 Y8

映射出的像素点为： \[Y0 U0 V5\] \[Y1 U0 V5\] \[Y2 U2 V7\] \[Y3 U2 V7\]
\[Y5 U0 V5\] \[Y6 U0 V5\] \[Y7U2 V7\] \[Y8 U2 V7\]

## 格式转换

### 小技巧

- RGB三个色值，如果都是0则显示黑色；如果都是255则为白色；如果是 在0－255范围内的**等值的时候是没有色相，是灰色的**。

- **YCbCr422要将Cb = 0x80 Cr = 0x80才能看到灰度图**。(有人会写成YUV422，其实是YCbCr422)

这些小技巧，可以通过以下公式证明。

### YCbCr与RGB的转换

转换公式一定要依据ITU的标准，常看到的是ITU.BT-601，ITU.BT-709和ITU.BT-2020。

这里重点介绍ITU.BT-601\[50\]。

![20161012193325724](//static.nykz.org/blog/images/2020-07-12/20161012193325724.avif)

把上述矩阵展开成方程式，如下所示

```java

Y = 0.299 R + 0.587 G + 0.114 B
Cb = -0.1687 R - 0.3313 G + 0.5 B + 128
Cr = 0.5 R - 0.4187 G - 0.0813 B + 128

R = Y + 1.402 (Cr - 128)
G= Y - 0.34414 (Cb - 128) - 0.71414 (Cr - 128)
B= Y + 1.772 (Cb - 128)

```

下边的各个符号都带了一撇，表示该符号在原值基础上进行了**伽马校正**，伽马校正有助于弥补在抗锯齿的过程中，线性分配伽马值所带来的细节损失，使图像细节更加丰富。在没有采用伽马校正的情况下，暗部细节不容易显现出来，而采用了这一图像增强技术以后，图像的层次更加明晰了。

```java

Y’ = 0.257 * R' + 0.504 * G' + 0.098 * B' + 16
Cb' = - 0.148 * R' - 0.291 * G' + 0.439 * B' + 128
Cr' = 0.439 * R' - 0.368 * G' - 0.071 * B' + 128
R' = 1.164 * (Y’ - 16) + 1.596 *(Cr' - 128)
G' = 1.164 * (Y’ - 16) - 0.813 * (Cr' - 128) - 0.392*(Cb' - 128)
B' = 1.164 * (Y’ - 16) + 2.017 * (Cb' - 128)
    
```

**H.264，H.265中YUV属于YCbCr**。

### YUV与RGB的转换

假设已经经过**伽马校正**，下边的都是带了一撇。

如下所示

```java

Y'= 0.299*R' + 0.587*G' + 0.114*B'
U'= -0.147*R' - 0.289*G' + 0.436*B' = 0.492*(B'- Y')
V'= 0.615*R' - 0.515*G' - 0.100*B' = 0.877*(R'- Y')

R' = Y' + 1.140*V'
G' = Y' - 0.394*U' - 0.581*V'
B' = Y' + 2.032*U'
    
```

是否上YUV与RGB转换公式需要加上128偏移，保证正值，我还没有相关的证据。
