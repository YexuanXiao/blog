---
title: C++已经取代C
date: "2022-11-19 02:40:00"
tags: [C++]
category: blog
---
本文是我在知乎上的[回答](https://www.zhihu.com/question/266995763/answer/2765466772)的复制，指出C和C++的发展不是孤立的，C 89在事实上采纳了C++方言而取代了原本的K\&R方言，并且未来的C标准也一直从C++中吸收新特性，因此C++实际上已经取代了C （K\&R版）并持续作为标准C的蓝图。

<!-- more -->

C++发明的早期（1980s）就有了和C一样庞大的用户量，并且在事实上推动了C的发展。例如ANSI C吸收了C++的 `void`，函数原型，`const` 等等，C99吸收了for初始化，`long long`，禁止隐式 `int`，// 注释，`inline`；C11吸收了原子操作，线程局部，对齐，Unicode，静态断言；C23吸收了大括号初始化，属性，数字分割，`nullptr`，布尔值。并且C23直接禁止了原始C的函数声明方式，只允许使用C++的方式。另外C++之父尤其重视类型安全，现在C的类型系统也是受C++影响而改进的。

C语言从C 89开始就已经存在着非常强烈的从C++吸收特性的趋势，Linus最近批准Linux使用C11，目的是为了引入for声明（C99加入），而这个特性在1980s就出现在C++中了。

现在写的所谓的C，如果拿到1989年（C第一次标准化）之前，不会有人认为是C，而会认为是C++，因为现在这种函数声明方式都是C++发明的。

C曾经有过很多方言，这些方言写法都有一定差异，C语言标准化的一部分原因就是为了消除其他方言，从这种角度讲，标准化的C选择了C++的C部分（C++方言）作为基础。并且现在C和C++的标准委员会也都有着比其他语言更为紧密的联系：C标准委员会和C++标准委员会会互相审核对方的一部分提案,以保持足够的兼容性。

工业界和主流的编译器GCC，Clang和MSVC都使用C++进行开发，而不是C，足以说明C++和C的关系和地位。因此，C和C++保持着紧密联系的同时在实际应用中选择了两个方向：如果项目不需要过多复杂特性，并且找不到足够的合格的C++程序员维护，或者要求编译结果更可控，那就选择C，如果不是，则使用C++。

有些人提到C的兼容性问题，我这里要指出，C的兼容性没梦想中那么好，Windows为了解决ABI问题要带一大堆MSVCRT.dll，而GCC在Linux上根本就不管兼容性，每一版GCC（glibc）都不保证和之前的版本兼容，兼容性好是因为没遇到或者有人擦屁股了而已，不是天生的。另外放在20年前，每个平台都有数个编译器，并且这些编译器都是商业化的，凭什么互相兼容，事实上也根本不兼容。C++之父在1994年的《D\&E》就指出了这一点，有些人却觉得C是2001年（x86\_64诞生，使得各大编译器进行了一次进化），或者2005年（Clang诞生）凭空冒出来的，之前的历史都不存在。
